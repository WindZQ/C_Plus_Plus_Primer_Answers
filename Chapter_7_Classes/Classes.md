## [练习7.1](7.1.cpp)

> 使用2.6.1节定义的Sales_data类为1.6节的交易处理程序编写一个新版本。

## [练习7.2](7.2.h)

> 曾在2.6.2节的练习中编写了一个Sales_data类，请向这个类添加combine函数和isbn成员。

## [练习7.3](7.3.cpp)

> 修改7.1.1节的交易处理程序，令其使用这些成员。

## [练习7.4](7.4.h)

> 编写一个名为Person的类，使其表示人员的姓名和地址。使用string对象存放这些元素，接下来的练习将不断充实这个类的其他特征。

## [练习7.5](7.5.h)

> 在你的Person类中提供一些操作使其能够返回姓名和地址。这些函数是否应该是const的呢？解释原因。

应该是const的。因为常量的Person对象也需要使用这些函数操作。

## [练习7.6](7.6.h)

> 对于函数add、read和print，定义你自己的版本。

## [练习7.7](7.7.cpp)

> 使用这些新函数重写7.1.2节练习中的程序。

## 练习7.8

> 为什么read函数将其Sales_data参数定义成普通的引用，而print函数将其参数定义成常量引用？

因为read函数会改变对象的内容，而print函数不会。

## [练习7.9](7.9.h)

> 对于7.1.2节练习中代码，添加读取和打印Person对象的操作。

## 练习7.10

> 在下面这条if语句中，条件部分的作用是什么？
```cpp
if (read(read(cin, data1), data2))
```

read 函数的返回值是 istream 对象，if语句中条件部分的作用是从输入流中读取数据给两个data对象。

## 练习7.11 : [头文件](7.11.h) | [主函数](7.11.cpp)

> 在你的Sales_data类中添加构造函数，然后编写一段程序令其用到每个构造函数。

## [练习7.12](7.12.h)

> 把只接受一个istream 作为参数的构造函数移到类的内部。

## [练习7.13](7.13.cpp)

> 使用istream构造函数重写第229页的程序。

## 练习7.14

> 编写一个构造函数，令其用我们提供的类内初始值显式地初始化成员。

```cpp
Sales_data() : units_sold(0) , revenue(0) { }
```

## [练习7.15](7.15.h)

> 为你的 Person 类添加正确的构造函数。

## 练习7.16

> 在类的定义中对于访问说明符出现的位置和次数有限定吗？如果有，是什么？什么样的成员应该定义在public 说明符之后？什么样的成员应该定义在private 说明符之后？

在类的定义中对于访问说明符出现的位置和次数没有限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者达到类的结尾处为止。

如果某个成员能够在整个程序内都被访问，那么它应该定义为 public; 如果某个成员只能在类内部访问，那么它应该定义为 private。

## 练习7.17

> 使用class 和 struct 时有区别吗？如果有，是什么？

class 和 struct 的唯一区别是默认的访问级别不同。

## 练习7.18

> 封装是何含义？它有什么用处？

将类内部分成员设置为外部不可见，而提供部分接口给外面，这样的行为叫做封装。封装隐藏了具体的实现，当我们使用某个抽象数据类型时，只需要考虑它提供什么接口操作，而不用去考虑它的具体实现。

## 练习7.19

> 在你的Person 类中，你将把哪些成员声明成public 的？哪些声明成private 的？解释你这样做的原因。

构造函数、`getName()`、`getAddress()` 函数将设为 public。`name` 和 `address` 将设为private。函数是暴露给外部的接口，因此要设为public；而数据则应该隐藏让外部不可见。

## 练习7.20

> 友元在什么时候有用？请分别举出使用友元的利弊。

当其他类或者函数想要访问当前类的私有变量时，这个时候应该用友元。

**利**：
* 与当前类有关的接口函数能直接访问类的私有变量。

**弊**：
* 牺牲了封装性与可维护性。
